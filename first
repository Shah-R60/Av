#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Function to check if a given string is a C keyword
int isCoreKeyword(const char *str) {
    const char *keywords[] = {
        "auto", "break", "case", "char", "const", "continue", "default", "do",
        "double", "else", "enum", "extern", "float", "for", "goto", "if",
        "int", "long", "register", "return", "short", "signed", "sizeof", "static",
        "struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while",
        "main", "printf", "scanf"
    };
    int num_keywords = sizeof(keywords) / sizeof(keywords[0]);
    for (int i = 0; i < num_keywords; i++) {
        if (strcmp(str, keywords[i]) == 0) {
            return 1;
        }
    }
    return 0;
}

// Function to check for preprocessor keywords
int isPreprocessorKeyword(const char *str) {
    if (strcmp(str, "include") == 0 || strcmp(str, "define") == 0 || strcmp(str, "ifdef") == 0) {
        return 1;
    }
    return 0;
}


// A helper function to print tokens consistently
void print_token(const char* token, const char* type) {
    printf("  Token: %-20s Type: %s\n", token, type);
}

// Main function to perform lexical analysis
void lexical_analyzer(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        perror("Error opening file");
        exit(EXIT_FAILURE);
    }

    char line[512];
    int line_num = 0;
    
    printf("--------------------------------------------------\n");
    printf("Lexical Analysis for file: %s\n", filename);
    printf("--------------------------------------------------\n");

    while (fgets(line, sizeof(line), file)) {
        line_num++;
        printf("\n--- Line %d: %s", line_num, line);
        
        int i = 0;
        while (line[i] != '\0') {
            // 1. Skip whitespace
            if (isspace(line[i])) {
                i++;
                continue;
            }

            // 2. Handle Preprocessor Directive Symbol '#'
            if (line[i] == '#') {
                print_token("#", "SYMBOL");
                i++;
                continue;
            }

            // 3. Handle comments
            if (line[i] == '/' && line[i+1] == '/') {
                break; 
            }

            // 4. Handle string and character literals
            if (line[i] == '"') {
                // ... (String literal logic is unchanged)
                print_token("\"", "SYMBOL"); i++;
                char buffer[256]; int j = 0;
                while (line[i] != '"' && line[i] != '\0') {
                    if (line[i] == '\\' && line[i+1] == '"') { buffer[j++] = line[i++]; buffer[j++] = line[i++]; } 
                    else { buffer[j++] = line[i++]; }
                }
                buffer[j] = '\0';
                if (strlen(buffer) > 0) { print_token(buffer, "STRING_LITERAL"); }
                if (line[i] == '"') { print_token("\"", "SYMBOL"); i++; } 
                else { printf("  Error: Unterminated string literal on line %d\n", line_num); }
                continue;
            }
            if (line[i] == '\'') {
                // ... (Char literal logic is unchanged)
                 print_token("'", "SYMBOL"); i++;
                char buffer[5]; int j = 0;
                while (line[i] != '\'' && line[i] != '\0') { buffer[j++] = line[i++]; }
                buffer[j] = '\0';
                print_token(buffer, "CHAR_LITERAL");
                if (line[i] == '\'') { print_token("'", "SYMBOL"); i++; } 
                else { printf("  Error: Unterminated char literal on line %d\n", line_num); }
                continue;
            }

            // 5. Handle multi-character operators (unchanged)
            char op_buffer[3] = {line[i], line[i+1], '\0'};
            if (strcmp(op_buffer, "==") == 0 || strcmp(op_buffer, "!=") == 0 ||
                strcmp(op_buffer, ">=") == 0 || strcmp(op_buffer, "<=") == 0 ||
                strcmp(op_buffer, "&&") == 0 || strcmp(op_buffer, "||") == 0) {
                print_token(op_buffer, "OPERATOR");
                i += 2;
                continue;
            }

            // 6. Handle identifiers, keywords, numbers, and headers
            if (isalpha(line[i]) || line[i] == '_') {
                char buffer[100];
                int j = 0;
                while (isalnum(line[i]) || line[i] == '_') {
                    buffer[j++] = line[i++];
                }
                buffer[j] = '\0';

                // *** MODIFIED LOGIC HERE ***
                if (isPreprocessorKeyword(buffer)) {
                    print_token(buffer, "KEYWORD");
                } else if (isCoreKeyword(buffer)) {
                    print_token(buffer, "KEYWORD");
                } else {
                    print_token(buffer, "IDENTIFIER");
                }
                continue;
            } 
            // This case specifically handles header files like <stdio.h>
            else if (line[i] == '<') {
                char buffer[100];
                int j = 0;
                while (line[i] != '>' && line[i] != '\0' && line[i] != '\n') {
                    buffer[j++] = line[i++];
                }
                if (line[i] == '>') {
                    buffer[j++] = line[i++];
                }
                buffer[j] = '\0';
                print_token(buffer, "HEADER_FILE");
                continue;
            }
            else if (isdigit(line[i]) || (line[i] == '.' && isdigit(line[i+1]))) {
                // ... (Number logic is unchanged)
                char buffer[100]; int j = 0;
                while (isdigit(line[i]) || line[i] == '.') { buffer[j++] = line[i++]; }
                buffer[j] = '\0';
                print_token(buffer, "CONSTANT");
                continue;
            } else {
                // 7. Handle remaining single characters (operators and symbols)
                char ch_str[2] = {line[i], '\0'};
                const char* operators = "+-*/%=!&|";
                const char* symbols = "(){}[] ,;"; 
                if (strchr(operators, line[i]) != NULL) {
                    print_token(ch_str, "OPERATOR");
                } else if (strchr(symbols, line[i]) != NULL) {
                    print_token(ch_str, "SYMBOL");
                }
                i++;
            }
        }
    }
    fclose(file);
}

int main() {
    char filename[] = "input.c";
    lexical_analyzer(filename);
    return 0;
}
